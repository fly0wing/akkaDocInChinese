.. _message-delivery-reliability:

############################
消息投递可靠性
############################

Akka助你构建一个可靠的应用程序，能够在单台机器上利用多个处理器内核("纵向扩展(scaling up)")或分布到一个计算机网络("横向扩展(scaling out)")。使之可行的关键抽象是，你的代码单元-actor-之间所有的交互-通过消息传递来进行，这就是actor之间消息传输的精确语义值得用专门的一章来讲述的原因。

为了针对以下的讨论给出一些上下文，设想一个跨越多个网络主机的应用程序。无论向本地JVM上的一个actor还是向一个远程actor发送消息，基本的通信机制是相同的，但是在投递延时（可能还依赖于网络链路带宽以及消息大小）和可靠性方面，当然会有一些可以观察的差异。在远程消息发送的情况下，很明显涉及更多步骤，这意味着可能出错的东西更多。另一个方面是，本地发送在同一个JVM中仅会传递指向这条消息的一个引用，对于其中被发送的对象没有任何限制，然而远程传输对消息大小会做出限制。

编写你的actor时，让每次交互都能够是远程的，是安全而谨慎的做法。这意味着只依赖于以下将详细介绍的这些总是会满足的性质。这在actor实现时当然会有一些开销。如果你愿意牺牲完全的地址透明性-例如在一组actor密切协作的情形下-你可以总是将它们放在同一个JVM上，并且享受消息投递的更严格保证。这一取舍的详情将在下面更深入地探讨。

作为一个补充部分，我们给出了一些关于如何在内建的可靠性的基础之上建立更强的可靠性的指南。本章以对“Dead Letter Office（死信邮局）”的探讨结束。

通用规则
=================

这些是消息发送方法（即 ``tell`` 或 ``!`` 方法）的规则，这也是 ``ask`` 模式的基础。

* **至多一次投递**, 也就是没有保障的投递
* **每对发送者-接收者之间的消息顺序**

第一条规则通常也会在其他actor实现中找到，但是第二条规则是Akka所独有的。

讨论：“至多一次”是什么意思？
------------------------------------------

谈到描述投递机制的语义，一共有三种基本类型:

* **至多一次** 投递意味着对于每条交给这一机制的消息，它会被投递0或1次；使用更加非正式的术语，这意味着消息可能会丢失。

* **至少一次** 投递意味着对于每条交给这一机制的消息，可能会在发送进行多次尝试，这样至少一次会成功；再次使用更加非正式的术语，这意味着消息可能重复，但不会丢失。

* **刚好一次** 投递意味着对于每条交给这一机制的消息，刚好一次投递会到达接收方；这条消息不会丢失也不会重复。

第一条是最经济的-性能最高，实现代价最低-因为它可以按照发出并忘掉的风格来进行，不必在发送端或传输机制中保留状态。第二个需要通过重试来抵消传输错误，而这意味着在发送端保留状态，并在接收端实现应答机制。第三个是最昂贵的-从而也具有最差的性能-因为在第二条的基础上，它还要求在接收端保留状态，从而滤掉重复的投递。

讨论: 为何使用无保证投递?
---------------------------------------

此问题的核心取决于另一个问题：这种保证应当到底是什么意思。

1. 这条消息被发送到网络上？
2. 这条消息由对端主机接收？
3. 这条消息被放入目标actor的信箱?
4. 这条消息正在开始被目标actor处理?
5. 这条消息由目标actor成功处理?

这其中的每一条都存在不同的挑战和代价，而且很明显其中某些条件，任何消息传输库都不能遵循；例如可以考虑可配置邮箱类型的例子，一个有限空间的邮箱如何实现第3条，甚至于如何确定第5点中“成功”部分的含义。

沿着同样的路线，能够通过推理得知 `Nobody Needs Reliable
Messaging`_. 让一个发送者得知一次交互是否成功的唯一有意义的方式是接收一个业务级别的应答，这不是Akka自身所能够生成的。（我们并不是在编写一个"照我所说的去做"的框架，而且你也不想让我们这么做）。

Akka拥抱分布式计算，并且通过消息传递将通信的不可靠暴露出来，因此它并不试图撒谎或模拟一个有漏洞的抽象。这是一个在Erlang中使用得极为成功的模型，并且要求用户围绕着这个模型设计他们的应用程序。你可以在 `Erlang documentation`_ (小节 10.9 和10.10)中阅读关于此方法的更多信息，Akka严格遵循它。

这个问题的另一个方面是，通过只提供基本的保证，那些不需要更强可靠性的使用案例，不需要付出实现的代价；在基本可靠性纸上总有可能添加更强的可靠性，但是不可能为了得到更好的性能而逆向移除一些可靠性。

.. _message-ordering:

讨论：消息排序
----------------------------

这条规则更具体的表述是 *对于一对给定的actor， 从第一个actor向第二个actor发送的消息不会被乱序接收。* 这可以进行如下阐述：

  Actor ``A1`` 发送消息 ``M1``, ``M2``, ``M3`` 到 ``A2``

  Actor ``A3`` 发送消息 ``M4``, ``M5``, ``M6`` 到 ``A2``
  
  这意味着:
      1) 如果 ``M1`` 被投递，则其投递必须先于 ``M2`` and ``M3``
      2) 如果 ``M2`` 被投递，则其投递必须先于 ``M3``
      3) 如果 ``M4`` 被投递，则其投递必须先于 ``M5`` and ``M6``
      4) 如果 ``M5`` 被投递，则其投递必须先于 ``M6``
      5) ``A2`` 可以交替地看到来自 ``A1`` 的消息与来自 ``A3`` 的消息。
      6) 由于是没有保证的投递这些消息中任何一个都可能丢失，即未到达 ``A2``

.. .. note::
::

  很重要的一点是，注意Akka的保证适用于消息被放入接收者邮箱队列的顺序。如果邮箱实现不遵循FIFO顺序（例如一个 :class:`PriorityMailbox` ）。

请注意这条规则是 **非传递** 的:

  Actor ``A`` 发送消息 ``M1`` 到 actor ``C``

  Actor ``A`` 然后发送消息 ``M2`` 到 actor ``B``

  Actor ``B`` 转发消息 ``M2`` 到 actor ``C``

  Actor ``C`` 可能以任何顺序收到 ``M1`` 和 ``M2``

简单的传递排序，将意味着 ``M2`` 绝不会在``M1`` 之前被 actor ``C`` 接收(尽管它们当中任何一个都可能丢失). 这一排序可能被违反，由于当 ``A``, ``B`` and
``C`` 位于不同网络节点时具有不同的延时。在下面查看更多内容。

.. .. note::
::

    Actor的创建被当做一条从父actor向子actor发送的消息。其语义跟上述所讨论的相同。按照一种可以同最初的创建消息重新排序的方式向一个actor发送一条消息，意味着当actor存在之前，那条消息不会抵达。一个消息可能导致过早抵达的例子是，创建一个远程部署的actor R1， 将其引用发送给另一个远程actor R2，并且让R2向R1发送一条消息。一个具有良好定义的顺序的例子是，一个父actor创建一个actor之后立刻向其发送一条消息。

错误的传递
........................

请注意，以上所讨论排序保证只对actor之间的用户消息成立。一个actor的子actor的错误是通过特殊的系统消息来传递的，其并不会相对于普通的用户消息来排序。详细地说：

  子actor ``C`` 发送消息 ``M`` 到其父actor ``P``

  子actor出错，错误为 ``F``

  父actor ``P`` 接收这两个事件的可能顺序为 ``M``, ``F`` 或 ``F``, ``M``

其原因是，系统内部消息具有其独立的信箱，因此用户和系统消息的入队调用的顺序不能保证其出队时间的顺序。

JVM内部(本地)消息发送的规则
==========================================

使用本节的知识所做的事情需要谨慎！
-----------------------------------------

不推荐依赖本节中的更强可靠性，因为这会将你的应用绑定到仅支持本地的部署：一个应用程序可能必须变更为不同的设计（与仅仅使用一些局限于某些actor的消息交换模式不同），从而能够适合于在一个集群上运行。我们的信条是： “一次设计，任意部署”，而要实现这一点，你必须仅仅依赖  `通用规则`_。

本地消息发送的可靠性
----------------------------------

Akka测试套件依赖于在本地环境中不丢失消息（并且对于不出错的条件测试，还依赖于远程部署中不丢失消息/and for non-error condition tests also for remote deployment），这意味着我们实际上付出了最大但努力来确保我们的测试是稳定的。但是一个本地的 ``tell`` 操作也是有可能出错的，其原因跟JVM上的普通方法一样:

- :class:`StackOverflowError`
- :class:`OutOfMemoryError`
- 其他 :class:`VirtualMachineError`

此外，本地消息发送还可能以Akka专有的方式失败：

- 当信箱不能接收这条消息 (例如塞满了的BoundedMailbox)
- 当接收消息的actor再处理消息时出错，或已经终止

第一个很显然是配置问题，而第二个值得仔细想想： 如果处理消息时出现异常，消息发送者并不会得到反馈，监管者才是通知抵达的地方。站在外部观察者的角度，这跟消息丢失是难以区分的。

本地消息发送的排序
-------------------------------

假设使用严格的FIFO信箱，上面所提到的消息顺序保证的不可传递性在特定条件下能够消除。正如你将注意到的，事实上这些特别细微，甚至有可能未来的性能优化将使得整个这一段内容都失效。可能不够详尽的一个禁忌（counter-indications）列表如下：

- 接收来自顶层actor的第一个响应之前，存在一个保护内部临时队列的锁，而这个锁并不公平；这暗示着在acter构造过程中来自不同发送者的入队请求(这只是比喻，细节更加复杂)可能依赖于低级线程调度而重排。因为JVM上不存在完全公平的锁，所以这个问题是不可修复的。

- 在构造一个Router时也使用了相同的机制，更精确地说，是被路由的ActorRef，因此对于跟Router一同部署的actor，存在着相同的问题。

- 如上所述，此问题发生在入队时加锁的任何地方，因此这可能也适用于自定义信箱.

这一列表是被仔细编辑的，但是其他有问题的场景可能超出了我们的分析。

本地排序与网络排序有何关系
--------------------------------------------------

如之前一段所述，本地消息发送在特定条件下遵循传递因果排序（transitive causal ordering）。如果远程消息传输也遵循这种排序，那将转换为单个网路链路上的传递因果排序，也就是，当刚好涉及两个网络节点。涉及多个链路，例如如上文所提到的三个不同节点上的三个actor，那就无法做出任何保证。

当前的远程传输确实 **不** 支持这一点 （这再一次是由锁的唤醒顺序呢并不遵循FIFO所导致的，这一次需要序列化的事件，是连接的建立）

作为一个猜测性观点，未来可能通过完全基于actor重新实现远程传输层，来支持这一排序保证；与此同时，我们正在研究提供其他低级传输协议，如UDP或SCTP，从而通过再次去掉这一保证来支持更高的吞吐量和更低的延迟，这意味着通过在不同实现之间做出选择，将能够在保证和性能间进行取舍。

高级抽象
=========================

基于Akka内核中的一个小巧而一致的工具集合，Akka还提供了强大的高级抽象。

消息模式
------------------

如上文所讨论，对于可靠投递需求的最直接回应，就是一个清晰的ACK-RETRY协议。在其最简单的形式中，它要求

- 一种识别单独消息的方式，从而将消息同应答相互关联
- 一种重发机制，当没有及时收到应答时重新发送消息
- 一种让接收者检测并丢弃重复消息的方式。

第三条由于应答也不能保证抵达而变得必要。一种包含业务级别应答的ACK-RETRY协议由Akka Persistence模块中的 :ref:`channels` 所支持。重复消息可以通过channel来跟踪所接收消息的序列号来检测。实现第三部分的另一种方式是，在业务逻辑层，使消息的处理是幂等的。

实现所有三条要求的另一个例子在 :ref:`reliable-proxy` （现已被 :ref:`channels` 取代）中有所展示。

事件溯源（event-sourcing）
--------------

事件溯源 (和分片) 是大型网站扩展到数十亿用户的方式，而其概念非常简单: 当一个组件 (想想actor) 处理一个命令时，它会生成表示此命令效果的一系列事件。这些事件除了对组件状态施加影响，还加以存储。这种方案的妙处在于，事件只是被追加到存储的末尾，任何东西都没有被修改; 这使得这个事件流的消费者能够进行完美的复制和扩展 (也就是，作为复制组件的一种方式，另一个组件可以在另一块大陆上消费事件流或者对变化做出反应)。 如果一个组件的状态被丢失-由于机器故障或被推出缓存-它可以通过回放事件流（通常使用快照来加速这一过程）来简单地重建。 :ref:`event-sourcing` 被Akka Persistence支持。

显式应答的邮箱
-------------------------------------

通过实现一个自定义信箱类型，可以接收消息的actor一端重试消息处理，从而处理临时故障。这种模式在本地通信环境中最有用，其中的投递保证在其他方面足够实现应用程序的需求。

请注意 `JVM内部(本地)消息发送的规则`_ 的危险是确实存在的。

此模式的一个示例实现在 :ref:`mailbox-acking` 中可见.

.. _deadletters:

死信
============

不能被投递的消息（在可以确定的情况下，and for which this can be ascertained）会被投递到一个捏造的actor称为 ``/deadLetters`` 。这种投递基于最大努力的原则而进行; 它甚至在本地JVM中都可能会失败(例如在actor终止的过程中). 通过不可靠的网络传输介质来发送的消息会丢失，而不是作为死信而出现。

我应该将死信用于何种目的？
-----------------------------------

这种设置的主要用途是调试，特别是当一个actor消息发送并没有一致地到达（在这种情况下，查看死信会被告知，发送者或接收者在路上被错误地设置）。为了可用于这种目的，最佳实践是尽可能避免发送死信，也就是在运行你的应用程序时经常使用合适的死信日志器（在下面查看更多信息），并且使日志输出清晰。这种用法-跟其他的一样-需要对常识进行批判性的应用：也可能出现这样的情形，为了避免向一个已终止的actor发送消息而向发送者的代码所增加的复杂度，超过了在调试输出清晰度方面所得到的益处。

在投递保证方面，死信服务其他全部消息发送遵循相同的规则，因此它不可被用于实现有保证的投递。

我如何接收死信？
------------------------------

一个actor可以订阅事件流上的 :class:`akka.actor.DeadLetter`, 参见 :ref:`event-stream-java` (Java) 或 :ref:`event-stream-scala`
(Scala) 来了解怎么做. 订阅的actor从此往后将受到所有发布到当前（本地）系统的死信。死信不能在网络上传播，如果你想在一处收集他们，你将不得不在每个网络节点使用一个actor来订阅死信，并且手动转发。还要考虑到的是，死信是在能够确定一次发送操作失败的节点上产生的，对于一次远程消息发送，这可能是本地系统（如果网络连接无法建立），或者远程系统（如果你所发送的消息的目标actor当时并不存在）

（通常）并不让人担心的死信
----------------------------------------------

每次当actor并非自发地终止时，它自己向自己所发送的一些消息有一定几率会丢失。有一个消息在复杂的关闭场景中经常出现，但通常是良性的：看到一个 :class:`akka.dispatch.Terminate` 落下，意味着已经给出两个终止请求，但是当然，只有一个能够成功。同样地，当你停止一个actor层次结构时，可能会看到来自子actor的 :class:`akka.actor.Terminated` 消息出现在死信中，如果在父actor终止时仍然在监视子actor的话。

.. _Erlang documentation: http://www.erlang.org/faq/academic.html
.. _Nobody Needs Reliable Messaging: http://www.infoq.com/articles/no-reliable-messaging

