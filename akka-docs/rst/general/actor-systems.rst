.. _actor-systems:

Actor系统
=============

Actors是封装了状态和行为的对象，它们只通过交换消息来进行通信，消息被放入接收者的信箱。在某种意义上, actor是面向对象编程的最严格形式，但是将它们看作人会更好:当使用actor来对一个解决方案进行建模时，想象一组人员，并且将子任务分配给他们，将他们的功能分配到一个有组织的结构当中，并且考虑如何将错误逐步升级（所有这些有个好处就是不需要实际与人打交道，这意味着我们不需要关心他们的情绪状态或道德问题）。然后这些结果就可以作为构建软件实现的思维框架。

.. note::

   ActorSystem是一种重量级的结构，会分配1…N个线程,
   因此一个逻辑应用程序中请只创建一个。

层次结构
----------------------

如同经济组织中一样, actor自然地形成层次结构. 一个管理程序中特定功能的actor，可能要将其任务拆分为更小的，更易于管理的任务块。为此，当它管理任务的时候，会启动子actor并进行监管。
监管的详情在此处进行了解释 :ref:`这里 <supervision>`， 我们应当集中关注本节中的基础内容。唯一的预备知识是，要知道每个actor的监管者恰好只有一个，那就是创建它的actor。
actor系统的精髓特性在于，任务被逐步拆分和委派，直到其变得足够小，能够单独处理。这样做，不仅使任务自身结构清晰，而且使得最终的actor所应当处理的消息，正常情况下如何反应，以及错误如何被处理都能够被推断。如果一个actor无法处理某种特定情况，它会向监管者发出一条相应的错误信息来求助。而后这个递归结构能够让错误在正确的层级被处理。
与之相比，分层软件设计很容易发展为防御式编程，其目标是不泄露出任何错误：相比较掩盖一切，问题被传达到正确的人能够得到更好的解决方案。
现在，设计这样一个系统的困难在于如何决定谁应当监管什么。这当然没有一个最好的解决方法，但是有很多可能有益的指导方针：

 - 如果一个acotr管理别的actor所做的工作，例如，通过分发子任务，那么管理actor应当监管子actor。原因是，管理者了解哪些类型的错误是有可能发生的，以及如何处理它们。
 - 如果一个actor携带非常重要的数据(也就是说，如果可以避免的话，其状态不应当被丢失)，这个actor应当向所监管的子actor分发任何可能存在危险的子任务，并且恰当地处理这些子actor的失败。根据请求的本质，最好能够为每次请求创建一个子actor，从而简化收集响应时的状态管理。这被称为“Error Kernel Pattern(错误内核模型)"，源于Erlang语言。
 - 如果一个actor依赖另一个actor来开展其职责，它应当观察另一个actor是否还活着，并且在接收到终止通知时做出响应。这跟监管是不同的，因为观察方对监管策略没有任何影响，并且值得注意的是，功能依赖并不能单独决定将一个特定的子actor放置于层次结构中哪个位置。

当然这些规则总会有例外，但是无论你遵循还是违背这些规则，你都应当有充分的理由。

配置容器
-----------------------

actor系统作为一整套相互协作的actor，是管理诸如调度服务，配置，日志等等共享设施的自然单元。具有不同配置的多个actor系统可能同时存在于同一个JVM中，而不会出现问题，Akka自身当中不存在全局的共享状态。
将这一点与actor系统之间的透明通讯-在一个节点内部，或者穿越网络连接—结合起来能够看到，actor系统自身可以作为一个功能层次结构中的基本组件。

Actor 最佳实践
--------------------

#. Actor应该像好同事: 高效率地完成它们的工作，不会没有必要地打扰别人，并且避免霸占资源。在编程中，这意味着按照事件驱动的风格来处理事件并生成响应（或更多的请求）。Actor不应当在一个外部实体上阻塞（也就是，在占据一个线程的情况下被动等待），这个外部实体可能是一个锁、一个网络socket等等——除非不可避免，在这种情况下参照下一条。阻塞操作应该在某些特殊的线程里完成，这个线程发送消息给可处理这些消息的actor们。

#. 不要在actor间传递可变对象。为了确保这一点，尽量使用不可变消息。如果actor将它们的可变状态暴露给外界从而打破了封装，你又会重新回到普通的Java并发编程，并承受其所有的缺点。

#. Actor用来做行为和状态的容器，遵循这一点就意味着不要在消息中传递行为（使用scala闭包时，这很有诱惑力）。风险之一是在actor之间意外地共享可变状态，而这种对actor模型的违背将破坏所有让actor编程体验良好的属性。

#. 顶层Actor是你的Error Kernel的最内层部分，因此请谨慎地创建它们，更多地使用真正层次化的系统。这对于故障处理(同时考虑配置粒度和性能)有利，并且也减少了守护actor(guardian actor)的压力,如果过度使用的话，守护actor是一个（contention）单点。

阻塞需要仔细管理
---------------------------------
在某些情况下执行阻塞操作是不可避免的,即把一个线程置于时间不确定的睡眠状态之中，等待一个外部事件的发生。例子是传统RDBMS驱动或消息传递api，而底层的原因通常是(网络)I/O在幕后发生。当面对这个问题，你可能会倾向于将阻塞调用包装于一个:class:`Future`中，并转而操作它。然而，但这一策略过于简单:当应用程序运行时的负载逐渐增加时，你很可能会找到瓶颈，或者耗尽内存或线程。
一份不够详尽的关于恰当解决"阻塞问题"的方法的清单包括如下建议：
- 在一个actor或着由一个路由所管理的一组actor之中执行阻塞调用。
[:ref:`Java <routing-java>`, :ref:`Scala <routing-scala>`]),确保配置一个专门的或者足够大的线程池。
- 在:class:`Future`之中执行阻塞调用, 确保这样调用的数量在任何时候都有一个上限(提交无数的这种性质的任务将会耗尽你的内存或线程)。
- 在:class:`Future`之中执行阻塞调用, 提供一个的线程池，其线程数上限适合于应用程序所运行的硬件。
- 用单个线程来管理一组阻塞资源（例如一个驱动多通道的NIO选择器），并且当事件以actor消息的形式到来时对其进行分发。

第一种可能的方案特别适合于本质上适合单线程访问的资源,如数据库句柄传统情况下一次只能执行一个外部查询，其使用内部同步来确保这一点。一种常见的模式是为N个Actor创建一个路由器,每个Actor包装一个DB连接，并且处理查询的方式为发送到路由器。为了达到最大吞吐量，N的大小必须进行调优，根据部署DBMS的硬件的不同而有所变化。

.. note::

    配置线程池是一项最好由Akka代为完成的任务，这只需在 ``application.conf`` 中进行配置，并通过一个 :class:`ActorSystem` [:ref:`Java <dispatcher-lookup-java>`, :ref:`Scala
<dispatcher-lookup-scala>`] 来进行实例化。

你不应该关心什么
-----------------------------------------
一个actor系统为了运行其所包含的actor，需要管理其根据配置所要使用的资源。 值得一提的是，在一个系统中可能有几百万个actor，可以认为它们是充足的，而每个actor实例仅有大约300字节的开销。自然地，一个大系统中消息的处理顺序是不受应用开发者控制的，但开发者也没有控制的意图。退后一步，放松些，让Akka在幕后完成那些繁重的任务吧。监管

