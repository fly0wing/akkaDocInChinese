.. _remoting:

位置透明性
=====================

上一节讲到了如何使用actor路径来实现位置透明性。这个特殊的值得进行一些额外的解释，因为相关术语“透明远程处理”在编程语言，平台和技术的上下文中具有非常不同的用法。

默认分布式
----------------------

Akka中的每件东西都被设计为在分布式的环境中工作：actor之间的所有交互都使用纯粹的消息传递，并且一切都是异步的。努力实现这些，是为了保证所有功能在单个JVM上和在数百台机器的集群里都能同样可用。做到这一点的关键在于通过优化的方式从远程延伸到本地，而不是试图通过一般化的方式从本地延伸到远程。参阅 `this classic paper
<http://doc.akka.io/docs/misc/smli_tr-94-29.pdf>`_ 来了解关于为何第二种方式必定失败的详细探讨。

透明性会被破坏的方式
------------------------------------

由于针对分布式执行进行设计对于可能实现的事情增加了一些限制，Akka所能满足的条件，使用akka的应用程序中并不需要满足。最显著的一点是，发送到网络的所有消息必须可序列化。尽管相对而言不那么明显，但是这（发送到网络上的内容）也包括在远程节点上创建actor时用作actor工厂的闭包（也就是在 :class:`Props` 中）。

另一个结果就是，所有元素都需要意识到，所有交互都是完全异步的，在一个计算机网络中，这可能意味着，一条消息可能需要好几分钟才能到达接收方（取决于配置）。还也意味着消息丢失的概率比在单一jvm中接近于0的概率（仍然不能硬性保证！）要高得多。

远程处理如何使用？
---------------------

我们把透明性的想法发挥到极致，以至于Akka中几乎没有远程处理层API：远程处理完全由配置驱动。只需按照之前的小节中概述的那些原则来编写你的应用，然后在配置文件里指定actor子树的远程部署方式。这样你的应用就可以在不碰触代码的情况下进行扩展。API中唯一允许采用编程方式来影响远程部署的部分是，:class:`Props` 包含一个字段，它可以被设置为一个指定的 :class:`Deploy` 实例；这与在配置文件中写入等价的部署信息具有相同的效果（如果两者都有，那么配置文件优先）。

点对点（P2P） vs. 客户端-服务器(C/S)
------------------------------

Akka Remoting(远程处理) 是一个用于使用P2P风格连接actor系统的通信模块，并且它是Akka Clustering(集群)的基础。远程处理的设计是由两大（相关）的设计决定来驱动的：

#. 所涉及的系统之间的通信是对等的：如果一个系统A可以连接到系统B，那么B必须也能够独立地连接到A。
#. 关于连接模式，通信系统的角色是对称的：没有任何系统只接受连接，也没有任何系统只发起连接。

这些决定的结果是，不可能安全地创建使用预定义角色的纯粹的客户端-服务器结构（违反第2条假设），并且使用配置涉及网络地址转换(NAT)或负载均衡（违反假设1）。

For client-server setups it is better to use HTTP or Akka I/O.
对于客户端-服务结构，更好的方式是使用HTTP或Akka I/O。

Marking Points for Scaling Up with Routers
使用路由来来标记垂直扩展点
------------------------------------------

除了可以在集群中的不同节点上运行一个actor系统的不同部分，还可以通过倍增actor子树的方式来垂直扩展到多个cpu核上，这能够支持并行（例如可以设想一个搜索引擎并行处理不同的查询）。克隆出的子树可以通过各种不同的方式而路由到，例如round-robin。要实现这一点，开发者只需要将一个特定的actor声明为“withRouter”，然后，取而代之的是，一个路由actor将被创建，它会生成具有所需类型的，数量可配置的一组子actor，并按照所配置的方式路由到这些子actor。一旦声明了这样的路由，它的配置可以自由地通过配置文件里进行覆盖，包括将其与(某些)子actor的远程部署进行混合。关于这些可参阅 :ref:`Routing (Scala) <routing-scala>` 和 :ref:`Routing (Java) <routing-java>` 。
