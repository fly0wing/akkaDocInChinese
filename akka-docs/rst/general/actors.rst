.. _actors-general:

Actor是什么?
=================
上一节 :ref:`actor-systems` 解释了actor如何形成一个层次结构，并且它们是创建一个应用的最小单元。本节单独来看看一个这样的actor，解释在实现它时会遇到的概念。如需包含所有细节的深度参考文档，请参阅
:ref:`Actors (Scala) <actors-scala>` and :ref:`Untyped Actors (Java) <untyped-actors-java>`.

Actor包含 `状态`_, `行为`_, a `信箱`_, `子Actor`_
and a `监管策略`_。 所有这些都封装于 `Actor引用`_. 背后。 最终, 这发生于 `Actor终止时`_.

Actor引用
---------------
如下详述，一个actor对象从actor模型中获益，需要与外界隔离。所以actor是以actor引用的形式展现给外界的，actor引用可以被自由传递，没有任何限制。内部对象和外部对象的划分使得所有需要的操作都具有透明性：重启actor不需要更新别处的引用，将实际的actor对象放置到远程主机上，向完全不同的应用程序中的actor发送消息。但最重要的方面是，不可能从外界看到actor对象的内部，并获取它的状态，除非这个actor自身非常不明智地将此信息公布出去。

状态
-----

Actor对象通常包含一些变量来反映actor所处的可能状态。这可能是一个显式的状态机（例如， 使用 :ref:`fsm-scala`  模块)，或是一个计数器，一组监听器，待处理的请求，等等。这些数据为actor赋予价值，而它们必须被保护起来，不被其它的actor所破坏。好消息是，在概念层面，每个Akka actor都拥有自己的轻量线程，这个线程是完全与系统其它部分想隔离的。这意味着你不需要使用锁来进行资源同步，可以在编写你的actor代码时完全不必担心并发性。

在幕后，Akka会在一组真实线程上运行一组Actor，其中通常很多actor共享一个线程，对某一个actor的后续调用可能会在不同的线程上进行处理。Akka保证这一实现细节不影响处理actor状态时的单线程性质。

由于内部状态对于actor的操作是至关重要的，所以状态不一致是致命的。当actor失败并由其监管者重新启动时，状态会被从头开始重新创建，如图第一次创建这个actor。这是为了实现系统的“自愈合”能力。

另外, 通过对所接收的消息进行持久化，并且在actor重启时回放，actor的状态能够自动还原到重启之前的状态。(参见 :ref:`persistence-scala`).

行为
--------
每当一个消息被处理时，它会根据actor的当前的行为来进行（模式）匹配。行为是一个函数，其定义了当时处理消息所采取的行动，例如，如果客户已经授权则将请求进行转发，否则拒绝之。这种行为可能随着时间推移而改变，原因如，不同的客户在不同的时间获得授权，或是actor进入“非服务”模式，之后又变回来。这些变化要么通过将其编码到状态变量中，并在行为逻辑中读取这些变量来实现，要么函数本身在运行时被换掉，见 ``become`` and ``unbecome`` 操作。但是actor对象在创建时所定义的行为是在某种意义上说是特殊的，就是当actor重启时会恢复这个初始行为。

信箱
-------

Actor的用途是处理消息，这些消息是从其它的actor（或者从actor系统外部）发送过来的。连接发送者与接收者的纽带是actor的邮箱：每个actor具有唯一的邮箱，所有发送者的消息都在其中排队。排队是根据发送操作的时间顺序来进行的，这意味着从不同的actor发来的消息在运行时没有确定的顺序，这是由于actor显然随机分布于不同的线程中。另一方面，从同一个actor发送多条消息到同一个actor时，消息会按相同的顺序排队。

存在不同的邮箱实现可供选择，默认为FIFO：actor处理消息的顺序与消息排队的顺序一致。这通常是很好的默认行为，但应用可能需要对某些消息进行优先处理。在这种情况下，一个带优先级的邮箱并不总会将消息排到队列末尾，而回根据消息优先级将消息放在某个位置，甚至可能是队列头部。如果使用这样的队列，消息的处理顺序自然由队列的算法来决定的，而不是FIFO。

Akka与其它actor模型实现的一个重要差别在于，当前的行为必须处理下一个出队的消息，Akka不会扫描邮箱来找到下一个匹配的消息。无法处理某个消息通常被当作故障，除非actor覆盖了这一行为。

子Actor
--------

每个actor都是一个潜在的监管者：如果它创建了子actor来分配子任务，它会自动地监管它们。子actor列表在actor的上下文中维护，actor可以访问它。对列表的更改是通过创建(``context.actorOf(...)``) or停止 (``context.stop(child)``)子actor来实现，并且这些更改会立刻生效。实际的创建和停止操作在幕后以异步的方式完成，这样它们就不会“阻塞”其监管者。

监管策略
-------------------

Actor的最后一部分是其用来处理子Actor故障的机制。错误处理然后由Akka透明地完成，将:ref:`supervision`中所描述的策略当中的一种应用于所发生的每一次故障。由于这一策略对于actor系统如何组织具有基础性的作用，所以一旦actor被创建之后，它就不能被修改。

考虑对每个actor只有唯一的此种策略，这意味着如果要将不同的策略应用于各式各样的子actor，这些子actor应该进行分组，并置于使用相应策略的中间监管者之下，再一次申明，根据任务划分为子任务的方式来组织actor系统的结构，是更好的选项。

Actor终止时
------------------------

一旦actor终止，也就是 失败的方式导致不能用重启，停止自己或者被其监管者停止来解决，它会释放自己的资源，将其邮箱中所有未处理的消息提取到系统的“死信信箱”，它会将这些信息转发到DeadLetters这一EventStream之中。而actor正在引用中的邮箱会被一个系统邮箱所替代，此系统邮箱会将所有新的消息重定向到DeadLetters这一EventStream之中。 但是这些操作基于尽力而为（best effort）的策略，所以不能依赖它来实现“保证投递（guaranteed delivery）”。

之所以不简单沉默地把这些消息扔掉，是受到我们的测试的启发：我们在事件总线上注册了TestEventListener来作为转发死信的目标，并且对于每个收到的死信，在日志中记录一条警告消息。这对于更快地解析测试失败非常有帮助。可想而知，这个功能也可以用于其他目的。


